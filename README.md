# Проектная работа 10 спринта

## Админка для создания рассылок менеджерами 

### Функциональные требования
* создания сообщений пользователям (с выбором способа доставки) для отправки сразу
* CRUD шаблонов сообщений, чтобы при отправке можно было выбрать. 
* отложенные сообщения (отправка через 4 часа): планирование запуска
* повторяющиеся сообщения (каждую пятницу, каждый новый год и т.д.)

### Нефункциональные требования:
* нагрузка = 0, так что можно и синхронный фреймворк без проблем
* безопасность - достаточно как в админке фильмов, доступ есть/нет через сервис auth 
* надёжность - требования низкие
* хранилище: 
  * шаблоны - порядок 1000 шт
  * рассылки - порядок 1000 шт
  * планировщик - то же самое

Итого, годится Django + Postgres + Celery Beat

## API нотификаций.
### Функциональные требования:
* обработка поступающих событий фиксированных (регистрация пользователя, появление нового фильма и т.д.)
* [опционально] отработка поступающих событий в свободном формате (user_id, template_id, subject, text, type: 
[email | sms | push] - это пример).


* Сценарий 1. Отправка письма о лайке комментария клиента:
  * UGC система, которая сохраняет лайк, отправляет запрос в API о новом событии.
  * Для примера реализуем отправку по Websocket каждого нового лайка с сохранением сообщения в БД Mailer-сервиса 
* Сценарий 2. Еженедельная рассылка перед выходными:
  * Генератор автоматических событий создаёт событие еженедельная рассылка и отправляет его в API.
  * Для примера реализуем отправку по Email новых закладок, добавленных пользователем за неделю 
    без сохранения в БД Mailer-сервиса
* Сценарий 3. Ручная рассылка от менеджера:
  * Админ-панель создаёт рассылку и отправляет запрос в API о новом событии.
  * Для примера реализуем отправку сообщения без сбора доп. данных из других сервисов. 
    Только шаблон + ФИО пользователя 
* Сценарий 4. Отправка приветственного email с подтверждением email-адреса
  * Сервис Auth при регистрации пользователя создаёт событие "пользователь зарегистрирован"

## Воркер(ы), который забирает сообщение из очереди и обрабатывает

### Функциональные требования: 
* Из переменных окружения воркер знает из какой очереди получать события и в какую точку обмена кидать события, если надо
* Забирает событие/сообщение из очереди, включая ID_рассылки и ID_пользователя (если отправка конкретному пользователю)
* Если не передан - запросить список адресатов с нужным часовым поясом и включенными уведомлениями в сервисе Нотификации
* Обогащает данными из других сервисов (например взять UGC список лайков за сутки)
* Принимает ID шаблона, забирает шаблон с сервиса Админки Рассылок / Планировщика
* Для единичных сообщений:
  * Воркер формирует сообщение (в шаблон вставляет имя и фамилию) и отправляет, передавая ID_рассылки 
* Для массовых рассылок:
  * Воркер получает список пользователей и для каждого пользователя кидает в очередь задачу на отправку
  * Далее эту задачу обрабатываем как для единичных рассылок

## Websocket сервер для мгновенных сообщений.

### Функциональные требования
* REST API, не забываем про авторизацию, дабы все подряд к нам не коннектились.
* По ID пользователя храним его соединения (массив на каждого пользователя)
* При удалении из массива по ID пользователя последнего соединения - удаляем ключ (ID пользователя)

### Нефункциональные требования:
* Память
  * Соединения websocket 100 000 * 70 КБ = 7 ГБ RAM (https://websockets.readthedocs.io/en/stable/topics/security.html#memory-usage)
  * Пока не масштабируем, но в дальнейшем можем сделать таблицу роутинга - на каком из инстансов какой пользователь
    держит соединение, чтобы направлять сообщение на этот инстанс, тогда можно горизонтально масштабировать

Хорошо бы предусмотреть использование https://www.rabbitmq.com/dlx.html, на случай если что-то сломалось, чтоб сообщение не пропало.



## Сервис UGC Ratings 
### Добавить
* Дату-время лайка
* API для получения списка лайков на отзывы пользователя за период


## Сервис рассылок
### Функциональные требования
* API для пользователя:
  * для включения и выключения уведомлений email (любых)
  * Сохранение часового пояса пользователя 
  * Сохранение данных для формирования рассылки по шаблону: ФИО, email
  * Получение списка отправленных уведомлений с пагинацией (для "колокольчика")
* API для воркеров:
  * Получение данных пользователей с включёнными уведомлениями в определённом часовом поясе: ФИО, email
  * Отправка уведомления с ID_рассылки/ID_уведомления с заполненным шаблоном на определённый Email.
    Сервис должен проверять, была ли данному пользователю уже произведена рассылка с данным ID_рассылки/ID_уведомления, 
    если нет - то отправлять и добавлять отправленное уведомление в историю отправленных уведомлений
* Должен поддерживать работу с разными сервисами отправки сообщений (Email, Push и т.д.)
  * Реализуем абстрактный класс для работы с сервис-провайдерами
  * Реализуем один конкретный класс для работы с сервисом отправки
### Нефункциональные требования
* Нагрузка
  * MAU 1 000 000 пользователей
  * 2 уведомления в день = 2 млн в день
  * Пик 80% за 20% времени = 1,8 млн / (24*60*60*0,2) = 1 800 000 / 17 280 = 104 RPS уведомлений в секунду
* Хранилище
  * 2 млн уведомлений * 30 дней = 60 млн записей
  * 2 млн уведомлений * 30 дней * 1..10 кб = 60..600 ГБ
  * Не нужны констрейнты на связи с другими таблицами
  * Нужно масштабирование на случай возрастания объёма данных
  * Хранилище пользователей 1 000 000 * 1 кб = 1 ГБ
* Безопасность:
  * API пользователей должен аутентифицировать пользователя, при этом мы можем его персональные данные запрашивать
    в сервисе Auth по API в этот же момент и сохранять обновлять их у себя в БД
